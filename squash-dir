#! /usr/bin/env sh
# (C) Martin VÃ¤th <martin@mvath.de>

Echo () {
	printf -- '%s\n' "${*}"
}

Error () {
	printf -- '%s: %s\n' "${0##*/}" "${*}" >&2
}

Die () {
	Error "${*}"
	exit 1
}

Usage () {
	Echo "Usage: ${0##*/} [option] status|restart|stop|start|zap [names]
Show the status of all squash_* initscripts or (re)start|stop them.
If [names] are given only the squash_[names] initscripts are considered.
Options:
  -s  Squash data on stop/restart even if THRESHOLD is not reached.
      This is done by temporarily creating DIR_CHANGE/.do-save
      if there is new data.
  -f  Restart also those scripts which would not save any data.
      If combined with -s, DIR_CHANGE/.do-save is created temporarily
      even if there is no new data.
  -e  Skip rest after first error (default)
  -E  Do not skip rest after first error
  -S  Cancel previous -s
  -F  Cancel previous -f"
	exit ${1:-1}
}

PrintInit () {
	printf -- '%-40s ' "${*}"
}

PrintComment () {
	printf -- '# %s\n' "${*}"
}

PrintAction () {
	printf -- '%-8s' "${1}"
	[ ${#} -gt 1 ] || return
	shift
	PrintComment "${*}"
}

PrintNoSave () {
	PrintAction 'stop'
	${1} || need_result=`"${2}" -q need_squash 2>&1`
	case "${need_result}" in
		0) PrintComment 'no modifications';;
		1) nosave=:; PrintComment 'modifications are not saved';;
		*) PrintComment "error: ${a}";;
	esac
}

Status () {
	local a
	PrintInit "${1}"
	if ! "${1}" -q status
	then	PrintAction 'start' 'might be necessary'
		return 0
	fi
	a=`"${1}" -q will_squash 2>&1`
	case "${a}" in
		0) PrintNoSave false "${1}";;
		1) PrintAction 'restart' 'will save modifications';;
		*) Error "error: ${a}"; return 1;;
	esac
	return 0
}

RemoveDosave () {
	[ -z "${dosave_file}" ] && return
	test -f "${dosave_file}" && rm -- "${dosave_file}"
	trap - EXIT HUP INT TERM
	dosave_file=''
}

CreateDosave () {
	local a
	a=`"${1}" print_dir_change 2>&1` && ! case "${a}" in */) false;; esac \
	|| {
		Error "error: ${1} print_dir_change: ${a}"
		return 1
	}
	a="${a}/.do-save"
	test -e "${a}" && return
	dosave_file="${a}"
	trap RemoveDosave EXIT HUP INT TERM
	: >"${dosave_file}" || {
		RemoveDosave
		return 1
	}
}

CheckStop () {
	local a
	checked_need=false
	will_restart=:
	dosave_file=''
	a=`"${1}" -q will_squash 2>&1`
	case "${a}" in
		0) :;;
		1) return 0;;
		*) Error "${1} error: ${a}"; return 1;;
	esac
	if ! ${save_force}
	then	will_restart=${force}
		return 0
	fi
	if ${force}
	then	CreateDosave "${1}"
		return
	fi
	checked_need=:
	need_result=`"${1}" -q need_squash 2>&1`
	case "${need_result}" in
		0) will_restart=false; return 0;;
		1) CreateDosave "${1}"; return;;
		*) Error "${1} error: ${a}"; return 1;;
	esac
}

Stop () {
	local a r
	a="${1}"
	shift
	if ! "${1}" -q status
	then	Echo "${1} is not running"
		return
	fi
	case "${a}" in
		rest*)	CheckStop "${1}" || return
			if ${will_restart}
			then	Echo "Restarting ${1}..."
				"${1}" restart && RemoveDosave
			else	PrintInit "${1}"
				PrintNoSave ${checked_need} "${1}"
			fi
			;;
		stop)	CheckStop "${1}" || return
			Echo "Stopping ${1}"
			"${1}" stop
			r=${?}
			RemoveDosave && return ${r}
			;;
		zap)	Echo "Zapping ${1}"
			"${1}" zap
			;;
	esac
}

Start () {
	if "${1}" -q status
	then	Echo "${1} was already started"
		return 0
	fi
	Echo "Starting ${1}..."
	"${1}" start
}

Doall () {
	local i j f a stat
	stat=0
	nosave=false
	case "${1}" in
		-*)	a="${1#-}"
			shift;;
		*)	a='';;
	esac
	f=${1}
	shift
	if [ ${#} -gt 0 ]
	then	for i
		do	case "${i}" in
				*/*) Die "argument ${i} is not a name";;
			esac
			test -x "/etc/init.d/squash_${i}" || \
				Die "/etc/init.d/squash_${i} not executable"
		done
	fi
	for i in /etc/init.d/squash_* "${@}"
	do	case "${i}" in
			*/squash_dir)
				continue;;
			/*)	[ ${#} -gt 0 ] && continue
				j="${i}";;
			*)	j="/etc/init.d/squash_${i}";;
		esac
		if ${error_skip} && [ ${stat} -ne 0 ]
		then	Echo "Skipping ${j} due to previous error"
			continue
		fi
		${f} ${a} "${j}" || stat=${?}
	done
	${nosave} && Echo "
# Modifications are not saved if either MAGICFILE exists or if
# there are not enough modifications to reach THRESHOLD.
# You can force saving by removing MAGICFILE (usually DIR_CHANGE/.no-save)
# resp. by creating an IGNORE_THRESHOLD file (usually DIR_CHANGE/.do-save).
# The latter happens if you call \"${0##*/}\" with option -s.
"
	exit ${stat}
}

force=false
error_skip=:
save_force=false
OPTIND=1
while getopts 'sSfFeE?hH' opt
do	case "${opt}" in
		s) save_force=:;;
		S) save_force=false;;
		f) force=:;;
		F) force=false;;
		e) error_skip=:;;
		E) error_skip=false;;
		*) Usage 0;;
	esac
done
shift $(( ${OPTIND} - 1 ))

opt="${1}"
[ ${#} -gt 0 ] && shift
case "${opt}" in
	stat*|sh*w|l*st|pr*nt|inf*)
		Doall Status "${@}";;
	re*)	Doall -restart Stop "${@}";;
	stop)	Doall -stop Stop "${@}";;
	zap)	Doall -zap Stop "${@}";;
	start)	Doall Start "${@}";;
	*)	Usage;;
esac
